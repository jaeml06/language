## 12장 함수

프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다

프로그래밍 언어의 함수도 입력을 받아서 출력을 내보낸다. 이때 함수 내부로 입력을 전달받는 변수를 매개 변수, 입력을 인수, 출력을 반환값이라 함

함수는 함수 정의를 통해 생성됨

```js
//함수 정의
function add(x, y){
    return x + y;
}

// 함수 정의만으로 함수가 실행되지 않고 
//인수를 매개변수로 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시해야 함
//이를 함수 호출이라 함.

// let result = add(2, 5);

console.log(result); // 7
```

함수를 사용하는 이유는 코드를 재사용측면에서 유리함. 코드의 중복을 줄이고 재사용성이 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있음. 또한 코드의 가독성을 향상시킴.



### 함수 리터널

```js 
//변수에 함수 리터널을 할당
let f = function add(x, y){
    return x + y; 
}
```



### 함수 정의 

함수 선언문

```js
//함수 선언문
function add(x, y){
    return x + y;
}
// 함수 참조
// console.dir // 함수의 프로퍼티까지 출력
//단 node.js환경에서는 console.log과 같은 결과가 출력됨

console.dir(add); // f add(x, y)

// 함수 호출
console.log(add(2,5)); // 7
```



```js
// 함수 선언문은 함수 이름을 생략할 수 없음
function (x, y){
    return x + y;
}

// SyntaxError
```

함수 선언문은 표현식이 아닌 문임. 콘솔에서 선언문을 실행하면 완료 값 undefined가 출력.



```js
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없음
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보임
let add = function add(x, y){
    return x + y;
};

console.log(add(2,5)) // 7
```

위와 같이 작동하는 이유는 자바스크립트 엔진이 코드 문맥에 따라 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우롸 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문

{}은 중의적 표현이므로 블록문일 수도 객체 리터럴일 수도 있음

```js
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석
// 함수 선언문에서는 함수 이름을 생략할 수 있음

function foo() {console.log('foo')}
foo() // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석
// 함수 리터럴에서는 함수 이름을 생략할 수 있음
(function bar() {console.log('bar');});
bar(); // ReferenceError
//foo bar 모두 함수 몸체 내부에서만 유효한 식별자임. 그러므로 foo로 함수를 호출할 수 없어야 함
//하지만 foo는 암묵적으로 생성됨
//bar는 함수 리터럴 표현식으로 bar로 호출 x
```

자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당함

함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출.



함수 표현식

자바스크립트의 함수는 일급 객체임. 일급 객체 : 값의 성질을 가지는 객체

```js
let add = function(x, y){
    return x + y;
};

console.log(add(2, 5)) // 7
//  함수 리터럴의 함수 이름은 생략할 수 있음. 이러한 함수를 익명함수라함.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 힘수 이름으로 함수를 호출할 수 없음
```



함수 생성 시점과 함수 호이스팅

```js
console.dir(add) // f add(x, y)
console.dir(sub) // undefined

//함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError

// 함수 선언문
function add(x, y){
    return x + y;
}
// 함수 표현식
let sub = function (x, y){
    return x - y;
}
// 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름.

```

함수 호이스팅 : 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

변수 호이스팅과 다름 let으로 선언된 변수는 undefined로 초기화 되고 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화됨.

 함수 표현식은 변수 할당문의 값은 할당문이 실행되는 시점, 런타임에 평가됨. 변수 호이스팅이 발생.

함수 표현식을 권장



Function 생성자 함수

```js
let add = new Function('x', 'y', 'return x + y');
console.log(add(2,5)); // 7

// Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않음

```



화살표 함수

```js
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```



### 함수 호출

매개변수와 인수 

```js
function add(x, y){
    return x + y;
}
console.log(add(2)) // NaN
// 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않음. 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined임
```

